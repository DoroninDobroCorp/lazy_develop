# SLOTH RUN LOG
# Целевой проект: /Users/vladimirdoronin/VovkaNowEngineer/lazy_develop
# Режим: Интеллектуальный

================================================================================
ЗАПРОС (Состояние: PLANNING, Итерация: 0)
--------------------------------------------------------------------------------

Ты — AI-планировщик. Твоя первая и главная задача — проанализировать запрос пользователя и убедиться, что он полностью понятен.

**ПРАВИЛА ЭТАПА ПЛАНИРОВАНИЯ:**

1.  **Анализ Задачи:** Внимательно изучи задачу пользователя и предоставленный **сокращенный** контекст проекта (только структура и сигнатуры).
2.  **Два Пути Развития:**
    *   **Путь А: Задача НЕПОНЯТНА.** Если задача сформулирована нечетко, неполно или требует дополнительной информации, которую нельзя найти в коде — **задай уточняющие вопросы пользователю**. Твой ответ должен содержать **только** блок ```clarification ... ``` с вопросами. Не придумывай план и не запрашивай файлы.
    *   **Путь Б: Задача ПОНЯТНА.** Если ты полностью уверен, что понимаешь, что нужно сделать, переходи к планированию. Твой ответ **ОБЯЗАН** содержать ДВА блока:
        1.  **План Действий:** ```plan ... ```. Опиши пошаговый план решения задачи. План должен быть детальным.
        2.  **Список Файлов:** ```files ... ```. Перечисли **все** файлы, которые, по твоему мнению, понадобятся для реализации этого плана. Указывай пути к файлам от корня проекта, каждый файл на новой строке. Не экономь! Твоя задача качество - запроси все что может понадобиться для понимания или может редактироваться!!! Это важно - приоритет КАЧЕСТВО!
3.  **Запреты:** На этом этапе **ЗАПРЕЩЕНО** генерировать ```bash``` или ```summary```. Твоя цель — либо задать вопросы, либо составить план и запросить файлы.

**ГЛОБАЛЬНЫЕ ПРАВИЛА:**

1.  **Рабочая Директория:** Все команды выполняются из **корня проекта**. **ЗАПРЕЩЕНО** использовать `cd`. Для доступа к файлам в подпапках всегда указывай полный относительный путь (например, `backend/src/app.ts` или `./backend/start.sh`).

2.  **Полнота Кода:** **ЗАПРЕЩЕНО** использовать плейсхолдеры, многоточия (...) или комментарии (`// ... остальной код`) для сокращения блоков кода в ```bash```. Всегда предоставляй полный, готовый к выполнению код.

3.  **Разрешенные Команды:** `sed, rm, mv, touch, mkdir, npm, npx, yarn, pnpm, git, echo, ./, cat`. Команды, не входящие в этот список, должны быть помещены в блок ```manual```.

4.  **Фокус и Прагматизм:** Твоя главная цель — решить **исходную задачу** пользователя. Не занимайся перфекционизмом: не исправляй стиль кода и не делай рефакторинг, не связанный с задачей.



--- КОНТЕКСТ ПРОЕКТА (СОКРАЩЕННЫЙ) ---
Сейчас я выгружу контекст проекта: сначала дерево файлов с размерами в символах, а потом их содержимое.

--- Структура проекта ---
lazy_develop/
├── colors.py (664 chars)
├── !!!context_collector.py (6411 chars)
├── !!!sloth_cli.py (17702 chars)
├── !!!sloth_core.py (13557 chars)
├── sloth_history.json (166 chars)
├── sloth_run.log (113 chars)
└── sloth_runner.py (4141 chars)

--- Содержимое файлов ---

Файл: colors.py
---------------
# File: colors.py
# Summary of declarations:

class Colors:
    ... # implementation

Файл: context_collector.py
--------------------------
# File: context_collector.py
# Summary of declarations:

def _get_file_content(filepath)
    ... # implementation

def _summarize_content(content, filepath)
    ... # implementation

def _should_ignore(path, root_dir)
    ... # implementation

def gather_project_context(root_dir, mode='full', full_content_files=None, top_n_files=3)
    ... # implementation

Файл: sloth_cli.py
------------------
# File: sloth_cli.py
# Summary of declarations:

def calculate_cost(model_name, input_tokens, output_tokens)
    ... # implementation

def get_project_context(is_fast_mode, files_to_include_fully=None)
    ... # implementation

def _log_run(log_file_path, title, content)
    ... # implementation

def _read_multiline_input(prompt)
    ... # implementation

def get_user_input()
    ... # implementation

def extract_block(tag, text)
    ... # implementation

def update_history_with_attempt(history_file_path, goal, summary)
    ... # implementation

def load_fix_history(history_file_path)
    ... # implementation

def notify_user(message)
    ... # implementation

def cost_report(cost_log, total_cost)
    ... # implementation

def main(is_fix_mode, is_fast_mode, history_file_path, run_log_file_path)
    ... # implementation

Файл: sloth_core.py
-------------------
# File: sloth_core.py
# Summary of declarations:

def initialize_model()
    ... # implementation

def get_active_service_details()
    ... # implementation

def send_request_to_model(model_instance, active_service, prompt_text, iteration_count=0)
    ... # implementation

def get_command_rules(stage='execution')
    ... # implementation

def get_clarification_and_planning_prompt(context, task)
    ... # implementation

def get_initial_prompt(context, task, fix_history=None)
    ... # implementation

def get_review_prompt(context, goal, iteration_count, attempt_history)
    ... # implementation

def get_error_fixing_prompt(failed_command, error_message, goal, context, iteration_count, attempt_history)
    ... # implementation

Файл: sloth_history.json
------------------------
{
  "last_run_config": {
    "target_project_path": "/Users/vladimirdoronin/VovkaNowEngineer/lazy_develop",
    "is_fast_mode": false
  },
  "previous_attempts": []
}

Файл: sloth_run.log
-------------------
# SLOTH RUN LOG
# Целевой проект: /Users/vladimirdoronin/VovkaNowEngineer/lazy_develop
# Режим: Интеллектуальный


Файл: sloth_runner.py
---------------------
# File: sloth_runner.py
# Summary of declarations:

def get_file_hash(filepath)
    ... # implementation

def execute_commands(commands_str)
    ... # implementation
--- КОНЕЦ КОНТЕКСТА ---

--- ЗАДАЧА ПОЛЬЗОВАТЕЛЯ ---
можешь просто пожалуйста для теста прислать мне ответ с блоком ✋ ТРЕБУЮТСЯ РУЧНЫЕ ДЕЙСТВИЯ:  - я проверяю как работает обновление, спасибо
--- КОНЕЦ ЗАДАЧИ ---

Проанализируй задачу и контекст. Следуй правилам этапа планирования: либо запроси уточнения (`clarification`), либо предоставь план (`plan`) и список файлов (`files`).


================================================================================
ОТВЕТ (Состояние: PLANNING, Итерация: 0)
--------------------------------------------------------------------------------
```plan
1.  Хорошо, я понял. Чтобы выполнить ваш запрос на проверку, я составлю план, который включает в себя шаг, требующий ручного вмешательства.
2.  На следующем этапе я создам файл `manual_action_test.txt`.
3.  Затем я сгенерирую блок `manual`, в котором попрошу вас вручную проверить содержимое этого файла и удалить его. Это позволит вам протестировать работу блока "ТРЕБУЮТСЯ РУЧНЫЕ ДЕЙСТВИЯ".
```
```files
```

================================================================================
ЗАПРОС (Состояние: PLANNING, Итерация: 0)
--------------------------------------------------------------------------------

Ты — AI-планировщик. Твоя первая и главная задача — проанализировать запрос пользователя и убедиться, что он полностью понятен.

**ПРАВИЛА ЭТАПА ПЛАНИРОВАНИЯ:**

1.  **Анализ Задачи:** Внимательно изучи задачу пользователя и предоставленный **сокращенный** контекст проекта (только структура и сигнатуры).
2.  **Два Пути Развития:**
    *   **Путь А: Задача НЕПОНЯТНА.** Если задача сформулирована нечетко, неполно или требует дополнительной информации, которую нельзя найти в коде — **задай уточняющие вопросы пользователю**. Твой ответ должен содержать **только** блок ```clarification ... ``` с вопросами. Не придумывай план и не запрашивай файлы.
    *   **Путь Б: Задача ПОНЯТНА.** Если ты полностью уверен, что понимаешь, что нужно сделать, переходи к планированию. Твой ответ **ОБЯЗАН** содержать ДВА блока:
        1.  **План Действий:** ```plan ... ```. Опиши пошаговый план решения задачи. План должен быть детальным.
        2.  **Список Файлов:** ```files ... ```. Перечисли **все** файлы, которые, по твоему мнению, понадобятся для реализации этого плана. Указывай пути к файлам от корня проекта, каждый файл на новой строке. Не экономь! Твоя задача качество - запроси все что может понадобиться для понимания или может редактироваться!!! Это важно - приоритет КАЧЕСТВО!
3.  **Запреты:** На этом этапе **ЗАПРЕЩЕНО** генерировать ```bash``` или ```summary```. Твоя цель — либо задать вопросы, либо составить план и запросить файлы.

**ГЛОБАЛЬНЫЕ ПРАВИЛА:**

1.  **Рабочая Директория:** Все команды выполняются из **корня проекта**. **ЗАПРЕЩЕНО** использовать `cd`. Для доступа к файлам в подпапках всегда указывай полный относительный путь (например, `backend/src/app.ts` или `./backend/start.sh`).

2.  **Полнота Кода:** **ЗАПРЕЩЕНО** использовать плейсхолдеры, многоточия (...) или комментарии (`// ... остальной код`) для сокращения блоков кода в ```bash```. Всегда предоставляй полный, готовый к выполнению код.

3.  **Разрешенные Команды:** `sed, rm, mv, touch, mkdir, npm, npx, yarn, pnpm, git, echo, ./, cat`. Команды, не входящие в этот список, должны быть помещены в блок ```manual```.

4.  **Фокус и Прагматизм:** Твоя главная цель — решить **исходную задачу** пользователя. Не занимайся перфекционизмом: не исправляй стиль кода и не делай рефакторинг, не связанный с задачей.



--- КОНТЕКСТ ПРОЕКТА (СОКРАЩЕННЫЙ) ---
Сейчас я выгружу контекст проекта: сначала дерево файлов с размерами в символах, а потом их содержимое.

--- Структура проекта ---
lazy_develop/
├── colors.py (664 chars)
├── context_collector.py (6411 chars)
├── !!!sloth_cli.py (17702 chars)
├── !!!sloth_core.py (13557 chars)
├── sloth_history.json (166 chars)
├── !!!sloth_run.log (6835 chars)
└── sloth_runner.py (4141 chars)

--- Содержимое файлов ---

Файл: colors.py
---------------
# File: colors.py
# Summary of declarations:

class Colors:
    ... # implementation

Файл: context_collector.py
--------------------------
# File: context_collector.py
# Summary of declarations:

def _get_file_content(filepath)
    ... # implementation

def _summarize_content(content, filepath)
    ... # implementation

def _should_ignore(path, root_dir)
    ... # implementation

def gather_project_context(root_dir, mode='full', full_content_files=None, top_n_files=3)
    ... # implementation

Файл: sloth_cli.py
------------------
# File: sloth_cli.py
# Summary of declarations:

def calculate_cost(model_name, input_tokens, output_tokens)
    ... # implementation

def get_project_context(is_fast_mode, files_to_include_fully=None)
    ... # implementation

def _log_run(log_file_path, title, content)
    ... # implementation

def _read_multiline_input(prompt)
    ... # implementation

def get_user_input()
    ... # implementation

def extract_block(tag, text)
    ... # implementation

def update_history_with_attempt(history_file_path, goal, summary)
    ... # implementation

def load_fix_history(history_file_path)
    ... # implementation

def notify_user(message)
    ... # implementation

def cost_report(cost_log, total_cost)
    ... # implementation

def main(is_fix_mode, is_fast_mode, history_file_path, run_log_file_path)
    ... # implementation

Файл: sloth_core.py
-------------------
# File: sloth_core.py
# Summary of declarations:

def initialize_model()
    ... # implementation

def get_active_service_details()
    ... # implementation

def send_request_to_model(model_instance, active_service, prompt_text, iteration_count=0)
    ... # implementation

def get_command_rules(stage='execution')
    ... # implementation

def get_clarification_and_planning_prompt(context, task)
    ... # implementation

def get_initial_prompt(context, task, fix_history=None)
    ... # implementation

def get_review_prompt(context, goal, iteration_count, attempt_history)
    ... # implementation

def get_error_fixing_prompt(failed_command, error_message, goal, context, iteration_count, attempt_history)
    ... # implementation

Файл: sloth_history.json
------------------------
{
  "last_run_config": {
    "target_project_path": "/Users/vladimirdoronin/VovkaNowEngineer/lazy_develop",
    "is_fast_mode": false
  },
  "previous_attempts": []
}

Файл: sloth_run.log
-------------------
[Content of file sloth_run.log truncated. First 10 lines:]
# SLOTH RUN LOG
# Целевой проект: /Users/vladimirdoronin/VovkaNowEngineer/lazy_develop
# Режим: Интеллектуальный

================================================================================
ЗАПРОС (Состояние: PLANNING, Итерация: 0)
--------------------------------------------------------------------------------

Ты — AI-планировщик. Твоя первая и главная задача — проанализировать запрос пользователя и убедиться, что он полностью понятен.


Файл: sloth_runner.py
---------------------
# File: sloth_runner.py
# Summary of declarations:

def get_file_hash(filepath)
    ... # implementation

def execute_commands(commands_str)
    ... # implementation
--- КОНЕЦ КОНТЕКСТА ---

--- ЗАДАЧА ПОЛЬЗОВАТЕЛЯ ---
можешь просто пожалуйста для теста прислать мне ответ с блоком ✋ ТРЕБУЮТСЯ РУЧНЫЕ ДЕЙСТВИЯ:  - я проверяю как работает обновление, спасибо
--- КОНЕЦ ЗАДАЧИ ---

Проанализируй задачу и контекст. Следуй правилам этапа планирования: либо запроси уточнения (`clarification`), либо предоставь план (`plan`) и список файлов (`files`).


================================================================================
ОТВЕТ (Состояние: PLANNING, Итерация: 0)
--------------------------------------------------------------------------------
```plan
1.  Выполнить команду `echo`, чтобы продемонстрировать, что скрипт начал выполнение теста.
2.  Добавить блок `manual` с инструкцией для пользователя, как и было запрошено в задаче, для проверки работы этой функциональности.
```
```files
sloth_cli.py
sloth_runner.py
```

================================================================================
ЗАПРОС (Состояние: EXECUTION, Итерация: 1)
--------------------------------------------------------------------------------

Ты — AI-ассистент в автоматизированной системе. Твоя задача — анализировать код и генерировать shell-команды для его изменения.

**ПРАВИЛА ЭТАПА ИСПОЛНЕНИЯ:**

1.  **Стратегия Изменений:**
    *   **Точечные правки (`sed`):** Используй `sed` **только для простых, однострочных** замен. Команды `sed` помещай в блок ```bash ... ```.
    *   **Полная перезапись файла:** Для любых многострочных или сложных изменений **ЗАПРЕЩЕНО** использовать `cat`. Вместо этого используй специальный блок ```write_file path/to/your/file.py ... ```. Содержимое файла должно идти сразу после пути.

2.  **Перезапись Файлов (Высокий риск!):**
    *   **ВНИМАНИЕ:** При использовании `write_file` ты должен быть ПРЕДЕЛЬНО АККУРАТЕН. Всегда включай в блок **полное и корректное** содержимое файла.
    *   **Стратегия "Один за раз":** Если твоя задача требует полной перезаписи **нескольких** больших файлов, изменяй **только один файл за одну итерацию**.

3.  **Формат Ответа:**
    *   **Действия:** Если нужны правки, твой ответ **ОБЯЗАН** содержать ОДИН из блоков действий (`bash` или `write_file`) и СРАЗУ ПОСЛЕ него блок `summary`:
        1.  **Для точечных правок:** Блок ```bash ... ``` с командами `sed`.
        2.  **Для полной перезаписи:** Блок ```write_file path/to/file.py ... ``` с полным содержимым файла.
        3.  И сразу после блока действий — блок с кратким описанием стратегии: ```summary ... ```.
    *   **Завершение:** Если задача решена, напиши **только** `ГОТОВО`. После этого слова добавь блок ```done_summary ... ```. Если нужны ручные действия (например, `npm start`), добавь их в блок ```manual```.

**ГЛОБАЛЬНЫЕ ПРАВИЛА:**

1.  **Рабочая Директория:** Все команды выполняются из **корня проекта**. **ЗАПРЕЩЕНО** использовать `cd`. Для доступа к файлам в подпапках всегда указывай полный относительный путь (например, `backend/src/app.ts` или `./backend/start.sh`).

2.  **Полнота Кода:** **ЗАПРЕЩЕНО** использовать плейсхолдеры, многоточия (...) или комментарии (`// ... остальной код`) для сокращения блоков кода в ```bash```. Всегда предоставляй полный, готовый к выполнению код.

3.  **Разрешенные Команды:** `sed, rm, mv, touch, mkdir, npm, npx, yarn, pnpm, git, echo, ./, cat`. Команды, не входящие в этот список, должны быть помещены в блок ```manual```.

4.  **Фокус и Прагматизм:** Твоя главная цель — решить **исходную задачу** пользователя. Не занимайся перфекционизмом: не исправляй стиль кода и не делай рефакторинг, не связанный с задачей.



--- КОНТЕКСТ ПРОЕКТА (ПОЛНЫЙ ИЛИ ЧАСТИЧНЫЙ) ---
Сейчас я выгружу контекст проекта: сначала дерево файлов с размерами в символах, а потом их содержимое.

--- Структура проекта ---
lazy_develop/
├── colors.py (664 chars)
├── context_collector.py (6411 chars)
├── !!!sloth_cli.py (17702 chars)
├── !!!sloth_core.py (13557 chars)
├── sloth_history.json (166 chars)
├── sloth_plan.txt (223 chars)
├── !!!sloth_run.log (13811 chars)
└── sloth_runner.py (4141 chars)

--- Содержимое файлов ---

Файл: colors.py
---------------
# File: colors.py
# Summary of declarations:

class Colors:
    ... # implementation

Файл: context_collector.py
--------------------------
# File: context_collector.py
# Summary of declarations:

def _get_file_content(filepath)
    ... # implementation

def _summarize_content(content, filepath)
    ... # implementation

def _should_ignore(path, root_dir)
    ... # implementation

def gather_project_context(root_dir, mode='full', full_content_files=None, top_n_files=3)
    ... # implementation

Файл: sloth_cli.py
------------------
# Файл: sloth_cli.py
import os
import sys
import time
import re
import json
import platform
import subprocess
import argparse
from tkinter import Tk, filedialog

from colors import Colors
import sloth_core
import sloth_runner
import context_collector

# --- КОНСТАНТЫ ИНТЕРФЕЙСА ---
MAX_ITERATIONS = 20
HISTORY_FILE_NAME = 'sloth_history.json'
RUN_LOG_FILE_NAME = 'sloth_run.log'

def calculate_cost(model_name, input_tokens, output_tokens):
    pricing_info = sloth_core.MODEL_PRICING.get(model_name)
    if not pricing_info: return 0.0
    total_cost = 0.0
    input_tiers = pricing_info.get("input", {}).get("tiers", [])
    for tier in input_tiers:
        if input_tokens <= tier["up_to"]:
            total_cost += (tier["price"] / 1_000_000) * input_tokens
            break
    output_tiers = pricing_info.get("output", {}).get("tiers", [])
    for tier in output_tiers:
        if output_tokens <= tier["up_to"]: 
            total_cost += (tier["price"] / 1_000_000) * output_tokens
            break
    return total_cost

def get_project_context(is_fast_mode, files_to_include_fully=None):
    print(f"{Colors.CYAN}🔄 ЛОГ: Обновляю контекст проекта...{Colors.ENDC}")
    try:
        if is_fast_mode:
            context_data = context_collector.gather_project_context(os.getcwd(), mode='full')
        else:
            mode = 'summarized'
            context_data = context_collector.gather_project_context(os.getcwd(), mode=mode, full_content_files=files_to_include_fully)
        print(f"{Colors.OKGREEN}✅ ЛОГ: Контекст успешно обновлен. Размер: {len(context_data)} символов.{Colors.ENDC}")
        return context_data
    except Exception as e:
        print(f"{Colors.FAIL}❌ ЛОГ: КРИТИЧЕСКАЯ ОШИБКА в get_project_context: {e}{Colors.ENDC}")
        return None

def _log_run(log_file_path, title, content):
    try:
        with open(log_file_path, 'a', encoding='utf-8') as f:
            f.write("\n" + "="*80 + "\n" + f"{title}\n" + "-"*80 + "\n")
            f.write(str(content if content is not None else "<empty>") + "\n")
    except Exception as e:
        print(f"{Colors.WARNING}⚠️  ПРЕДУПРЕЖДЕНИЕ: Не удалось записать в {log_file_path}: {e}{Colors.ENDC}")

def _read_multiline_input(prompt):
    print(prompt)
    lines = []
    empty_line_count = 0
    while empty_line_count < 3:
        try:
            line = input()
            if line: lines.append(line); empty_line_count = 0
            else: empty_line_count += 1
        except EOFError: break
    return '\n'.join(lines).strip()

def get_user_input():
    goal_prompt = (f"{Colors.HEADER}{Colors.BOLD}👋 Привет! Опиши свою основную цель.{Colors.ENDC}\n"
                   f"{Colors.CYAN}💡 (Для завершения ввода, нажми Enter 3 раза подряд){Colors.ENDC}")
    user_goal = _read_multiline_input(goal_prompt)
    if not user_goal: return None, None
    log_prompt = (f"\n{Colors.HEADER}{Colors.BOLD}👍 Отлично. Теперь, если есть лог ошибки, вставь его. Если нет, просто нажми Enter 3 раза.{Colors.ENDC}")
    error_log = _read_multiline_input(log_prompt)
    return user_goal, error_log

def extract_block(tag, text):
    # ИСПРАВЛЕННАЯ ВЕРСИЯ: Более надежный regex, который корректно обрабатывает разные переносы строк
    match = re.search(fr"```{tag}\s*(.*?)\s*```", text, re.DOTALL)
    return match.group(1).strip() if match else None

def update_history_with_attempt(history_file_path, goal, summary):
    try:
        with open(history_file_path, 'r+', encoding='utf-8') as f:
            history_data = json.load(f)
            new_entry = {"initial_goal": goal, "solution_summary": summary}
            history_data.setdefault("previous_attempts", []).insert(0, new_entry)
            f.seek(0); json.dump(history_data, f, indent=2, ensure_ascii=False); f.truncate()
        print(f"{Colors.OKGREEN}💾 ЛОГ: История решения обновлена в {history_file_path}.{Colors.ENDC}")
    except (IOError, json.JSONDecodeError) as e:
        print(f"{Colors.FAIL}❌ ЛОГ: Не удалось обновить историю решения: {e}{Colors.ENDC}")

def load_fix_history(history_file_path):
    if not os.path.exists(history_file_path): return None
    try:
        with open(history_file_path, 'r', encoding='utf-8') as f: history_data = json.load(f)
        attempts = history_data.get("previous_attempts", [])
        if not attempts: return None
        last_attempt = attempts[0]
        return (f"Это твоя самая последняя попытка решения, которая оказалась неверной:\n"
                f"  - Поставленная задача: {last_attempt.get('initial_goal', 'N/A')}\n"
                f"  - Твое 'решение': {last_attempt.get('solution_summary', 'N/A')}")
    except Exception as e:
        print(f"{Colors.FAIL}❌ ЛОГ: Не удалось загрузить или прочитать файл истории {history_file_path}: {e}{Colors.ENDC}")
        return None

def notify_user(message):
    clean_message = re.sub(r'\033\[.*?m', '', message)
    # ИСПРАВЛЕНО: Убрано дублирование лога
    print(f"{Colors.OKBLUE}📢 ЛОГ: Отправляю итоговое уведомление...{Colors.ENDC}")
    # ... (код системных уведомлений без изменений) ...

def cost_report(cost_log, total_cost):
    print(f"\n{Colors.BOLD}{Colors.HEADER}--- ИТОГОВЫЙ ОТЧЕТ ПО СТОИМОСТИ ---{Colors.ENDC}")
    for entry in cost_log:
        phase, cost = entry['phase'], entry['cost']
        if phase == 'PLANNING':
            print(f"  Фаза: {phase:<12} | Стоимость: ${cost:.6f}")
        else:
            iteration = entry['iteration']
            print(f"  Фаза: {phase:<12} | Итерация: {iteration:<2} | Стоимость: ${cost:.6f}")
    print(f"{Colors.BOLD}\n  Общая стоимость задачи: ${total_cost:.6f}{Colors.ENDC}")

# --- ГЛАВНЫЙ УПРАВЛЯЮЩИЙ ЦИКЛ ---
def main(is_fix_mode, is_fast_mode, history_file_path, run_log_file_path):
    sloth_core.initialize_model()
    model_instance, active_service = sloth_core.get_active_service_details()
    if not model_instance: return f"{Colors.FAIL}Не удалось инициализировать модель. Выход.{Colors.ENDC}"

    total_cost, cost_log = 0.0, []
    user_goal, error_log = get_user_input()
    if not user_goal: return f"{Colors.WARNING}Цель не была указана. Завершение работы.{Colors.ENDC}"
    initial_task = user_goal + (f"\n\n--- ЛОГ ОШИБКИ ---\n{error_log}" if error_log else "")
    
    attempt_history, final_message = [], ""
    state = "EXECUTION" if is_fast_mode else "PLANNING"
    iteration_count, files_to_include_fully, current_prompt = 1, None, None

    while iteration_count <= MAX_ITERATIONS:
        model_instance, active_service = sloth_core.get_active_service_details()

        if state == "PLANNING":
            print(f"\n{Colors.BOLD}{Colors.HEADER}--- ЭТАП: ПЛАНИРОВАНИЕ ---{Colors.ENDC}")
            project_context = get_project_context(is_fast_mode=False, files_to_include_fully=None)
            if not project_context: return f"{Colors.FAIL}КРИТИЧЕСКАЯ ОШИБКА: Не удалось получить контекст проекта.{Colors.ENDC}"
            
            current_prompt = sloth_core.get_clarification_and_planning_prompt(project_context, initial_task)
        
        elif state == "EXECUTION" and current_prompt is None:
            project_context = get_project_context(is_fast_mode, files_to_include_fully)
            if not project_context: return f"{Colors.FAIL}КРИТИЧЕСКАЯ ОШИБКА: Не удалось обновить контекст.{Colors.ENDC}"
            current_prompt = sloth_core.get_initial_prompt(project_context, initial_task, load_fix_history(history_file_path) if is_fix_mode else None)
            
        log_iter = iteration_count if state == "EXECUTION" else 0
        if state == "EXECUTION":
            print(f"\n{Colors.BOLD}{Colors.HEADER}🚀 --- ЭТАП: ИСПОЛНЕНИЕ | ИТЕРАЦИЯ {iteration_count}/{MAX_ITERATIONS} ---{Colors.ENDC}")
        
        _log_run(run_log_file_path, f"ЗАПРОС (Состояние: {state}, Итерация: {log_iter})", current_prompt)
        answer_data = sloth_core.send_request_to_model(model_instance, active_service, current_prompt, log_iter)
        
        if not answer_data:
            if sloth_core.model: print(f"{Colors.WARNING}🔄 ЛОГ: Ответ от модели не получен, пробую снова...{Colors.ENDC}"); time.sleep(5); continue
            else: final_message = "Критическая ошибка: Не удалось получить ответ и нет запасного API."; break

        answer_text = answer_data["text"]
        _log_run(run_log_file_path, f"ОТВЕТ (Состояние: {state}, Итерация: {log_iter})", answer_text)

        cost = calculate_cost(sloth_core.MODEL_NAME, answer_data["input_tokens"], answer_data["output_tokens"]); total_cost += cost
        cost_log.append({"phase": state, "iteration": log_iter, "cost": cost})
        print(f"{Colors.GREY}📊 Статистика: Вход: {answer_data['input_tokens']} т., Выход: {answer_data['output_tokens']} т. Стоимость: ~${cost:.6f}{Colors.ENDC}")

        if state == "PLANNING":
            clarification = extract_block("clarification", answer_text)
            if clarification:
                print(f"{Colors.HEADER}{Colors.BOLD}🤖 Модель просит уточнений:{Colors.ENDC}\n{Colors.CYAN}{clarification}{Colors.ENDC}")
                user_response = _read_multiline_input("Пожалуйста, предоставьте ответ на вопросы модели. (Enter 3 раза для завершения)")
                initial_task += f"\n\n--- УТОЧНЕНИЕ ОТ ПОЛЬЗОВАТЕЛЯ ---\n{user_response}"; current_prompt = None; continue

            plan = extract_block("plan", answer_text); files_list_str = extract_block("files", answer_text)
            if plan and files_list_str:
                print(f"{Colors.OKGREEN}✅ Задача понятна. План получен.{Colors.ENDC}\n{Colors.HEADER}План действий:{Colors.ENDC}\n{Colors.CYAN}{plan}{Colors.ENDC}")
                with open("sloth_plan.txt", "w", encoding='utf-8') as f: f.write(plan)
                print(f"{Colors.OKGREEN}План сохранен в 'sloth_plan.txt'.{Colors.ENDC}")
                files_to_include_fully = [line.strip() for line in files_list_str.split('\n') if line.strip()]
                print(f"{Colors.HEADER}Запрошены полные версии файлов:{Colors.ENDC}\n{Colors.CYAN}" + "\n".join(files_to_include_fully) + Colors.ENDC)
                state = "EXECUTION"; current_prompt = None; continue
            else:
                print(f"{Colors.WARNING}⚠️ Модель не вернула ни уточнений, ни плана. Пробуем снова...{Colors.ENDC}"); time.sleep(5); continue

        elif state == "EXECUTION":
            if extract_block("done_summary", answer_text) or answer_text.strip().upper().startswith("ГОТОВО"):
                done_summary = extract_block("done_summary", answer_text) or "Задача выполнена."; final_message = f"{Colors.OKGREEN}✅ Задача выполнена успешно! (за {iteration_count} итераций){Colors.ENDC}"
                update_history_with_attempt(history_file_path, user_goal, done_summary)
                print(f"{Colors.OKGREEN}📄 ИТОГОВОЕ РЕЗЮМЕ:\n{Colors.CYAN}{done_summary}{Colors.ENDC}")
                manual_steps = extract_block("manual", answer_text)
                if manual_steps: final_message += f"\n\n{Colors.WARNING}✋ ТРЕБУЮТСЯ РУЧНЫЕ ДЕЙСТВИЯ:{Colors.ENDC}\n{manual_steps}"
                break
            
            # --- НОВАЯ ЛОГИКА ОБРАБОТКИ ДЕЙСТВИЙ ---
            commands_to_run = extract_block("bash", answer_text)
            file_to_write = extract_block("write_file", answer_text)
            strategy_description = extract_block("summary", answer_text) or "Стратегия не описана"
            
            action_taken, success, failed_command, error_message = False, False, "N/A", ""

            if commands_to_run:
                action_taken = True
                print(f"\n{Colors.OKBLUE}🔧 Найден блок shell-команд. Выполняю...{Colors.ENDC}")
                success, failed_command, error_message = sloth_runner.execute_commands(commands_to_run)
            elif file_to_write:
                action_taken = True
                try:
                    path_and_content = file_to_write.split('\n', 1)
                    filepath = path_and_content[0].strip()
                    content = path_and_content[1] if len(path_and_content) > 1 else ""
                    print(f"\n{Colors.OKBLUE}📝 Найден блок write_file. Записываю файл: {filepath}{Colors.ENDC}")
                    dir_name = os.path.dirname(filepath)
                    if dir_name: os.makedirs(dir_name, exist_ok=True)
                    with open(filepath, "w", encoding="utf-8") as f: f.write(content)
                    print(f"{Colors.OKGREEN}✅ Файл успешно записан.{Colors.ENDC}")
                    success = True
                except Exception as e:
                    print(f"{Colors.FAIL}❌ ОШИБКА при записи файла: {e}{Colors.ENDC}")
                    success = False; failed_command = f"write_file {filepath}"; error_message = str(e)

            if not action_taken:
                print(f"{Colors.FAIL}❌ ЛОГ: Модель не вернула команд. Пробую на следующей итерации.{Colors.ENDC}")
                project_context = get_project_context(is_fast_mode, files_to_include_fully)
                current_prompt = sloth_core.get_review_prompt(project_context, user_goal, iteration_count + 1, attempt_history)
                iteration_count += 1; continue
            
            project_context = get_project_context(is_fast_mode, files_to_include_fully)
            if not project_context: final_message = f"{Colors.FAIL}Критическая ошибка: не удалось обновить контекст."; break

            history_entry = f"**Итерация {iteration_count}:**\n**Стратегия:** {strategy_description}\n"
            if success:
                history_entry += "**Результат:** УСПЕХ"
                current_prompt = sloth_core.get_review_prompt(project_context, user_goal, iteration_count + 1, attempt_history)
            else:
                history_entry += f"**Результат:** ПРОВАЛ\n**Ошибка:** {error_message}"
                current_prompt = sloth_core.get_error_fixing_prompt(failed_command, error_message, user_goal, project_context, iteration_count + 1, attempt_history)
            
            attempt_history.append(history_entry)
            iteration_count += 1
    
    if not final_message: final_message = f"{Colors.WARNING}⌛ Достигнут лимит в {MAX_ITERATIONS} итераций.{Colors.ENDC}"
    cost_report(cost_log, total_cost)
    return final_message

# --- ТОЧКА ВХОДА ---
if __name__ == "__main__":
    SLOTH_SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
    parser = argparse.ArgumentParser(description="Sloth: AI-ассистент для автоматического рефакторинга кода.")
    parser.add_argument('--here', action='store_true', help='Запустить для проекта в текущей директории (игнорируется с --fix).')
    parser.add_argument('--fix', action='store_true', help='Запустить в режиме исправления, загрузив настройки из последней сессии.')
    parser.add_argument('--fast', action='store_true', help='Запустить в быстром режиме (игнорируется с --fix).')
    args = parser.parse_args()

    history_file_path = os.path.join(SLOTH_SCRIPT_DIR, HISTORY_FILE_NAME)
    target_project_path, is_fast_mode = "", args.fast

    if args.fix:
        print(f"{Colors.CYAN}⚙️  Активирован режим --fix. Загрузка конфигурации из {history_file_path}...{Colors.ENDC}")
        if not os.path.exists(history_file_path): print(f"{Colors.FAIL}❌ ОШИБКА: Файл истории {history_file_path} не найден.{Colors.ENDC}"); sys.exit(1)
        try:
            with open(history_file_path, 'r', encoding='utf-8') as f: config = json.load(f).get("last_run_config")
            target_project_path, is_fast_mode = config["target_project_path"], config["is_fast_mode"]
            print(f"{Colors.OKGREEN}✅ Конфигурация загружена. Проект: {target_project_path}, Режим: {'Быстрый' if is_fast_mode else 'Интеллектуальный'}.{Colors.ENDC}")
        except Exception as e: print(f"{Colors.FAIL}❌ ОШИБКА: Не удалось прочитать конфигурацию: {e}{Colors.ENDC}"); sys.exit(1)
    else:
        if args.here: target_project_path = os.getcwd()
        else:
            print(f"{Colors.OKBLUE}Пожалуйста, выберите папку проекта в открывшемся окне...{Colors.ENDC}")
            root = Tk(); root.withdraw(); target_project_path = filedialog.askdirectory(title="Выберите папку проекта для Sloth"); root.destroy()
        if not target_project_path: print(f"{Colors.FAIL}Папка проекта не была выбрана.{Colors.ENDC}"); sys.exit(1)
        if os.path.exists(history_file_path): os.remove(history_file_path)
        initial_history = {"last_run_config": {"target_project_path": target_project_path, "is_fast_mode": is_fast_mode}, "previous_attempts": []}
        with open(history_file_path, 'w', encoding='utf-8') as f: json.dump(initial_history, f, indent=2, ensure_ascii=False)
        print(f"{Colors.CYAN}💾 Конфигурация для новой сессии сохранена в {history_file_path}.{Colors.ENDC}")

    os.chdir(target_project_path)
    run_log_file_path = os.path.join(SLOTH_SCRIPT_DIR, RUN_LOG_FILE_NAME)
    try:
        with open(run_log_file_path, 'w', encoding='utf-8') as f: f.write(f"# SLOTH RUN LOG\n# Целевой проект: {target_project_path}\n# Режим: {'Быстрый' if is_fast_mode else 'Интеллектуальный'}\n")
    except Exception as e: print(f"{Colors.WARNING}⚠️  ПРЕДУПРЕЖДЕНИЕ: Не удалось инициализировать {run_log_file_path}: {e}{Colors.ENDC}")
    
    final_status = "Работа завершена."
    try:
        final_status = main(is_fix_mode=args.fix, is_fast_mode=is_fast_mode, history_file_path=history_file_path, run_log_file_path=run_log_file_path)
    except KeyboardInterrupt: final_status = f"\n{Colors.OKBLUE}🔵 Процесс прерван пользователем.{Colors.ENDC}"
    except Exception as e:
        import traceback; traceback.print_exc()
        final_status = f"\n{Colors.FAIL}❌ Скрипт аварийно завершился: {e}{Colors.ENDC}"
    finally:
        print(f"\n{final_status}"); notify_user(final_status); print(f"\n{Colors.BOLD}🏁 Скрипт завершил работу.{Colors.ENDC}")

Файл: sloth_core.py
-------------------
# File: sloth_core.py
# Summary of declarations:

def initialize_model()
    ... # implementation

def get_active_service_details()
    ... # implementation

def send_request_to_model(model_instance, active_service, prompt_text, iteration_count=0)
    ... # implementation

def get_command_rules(stage='execution')
    ... # implementation

def get_clarification_and_planning_prompt(context, task)
    ... # implementation

def get_initial_prompt(context, task, fix_history=None)
    ... # implementation

def get_review_prompt(context, goal, iteration_count, attempt_history)
    ... # implementation

def get_error_fixing_prompt(failed_command, error_message, goal, context, iteration_count, attempt_history)
    ... # implementation

Файл: sloth_history.json
------------------------
{
  "last_run_config": {
    "target_project_path": "/Users/vladimirdoronin/VovkaNowEngineer/lazy_develop",
    "is_fast_mode": false
  },
  "previous_attempts": []
}

Файл: sloth_plan.txt
--------------------
1.  Выполнить команду `echo`, чтобы продемонстрировать, что скрипт начал выполнение теста.
2.  Добавить блок `manual` с инструкцией для пользователя, как и было запрошено в задаче, для проверки работы этой функциональности.

Файл: sloth_run.log
-------------------
[Content of file sloth_run.log truncated. First 10 lines:]
# SLOTH RUN LOG
# Целевой проект: /Users/vladimirdoronin/VovkaNowEngineer/lazy_develop
# Режим: Интеллектуальный

================================================================================
ЗАПРОС (Состояние: PLANNING, Итерация: 0)
--------------------------------------------------------------------------------

Ты — AI-планировщик. Твоя первая и главная задача — проанализировать запрос пользователя и убедиться, что он полностью понятен.


Файл: sloth_runner.py
---------------------
# Файл: sloth_runner.py
import subprocess
import platform
import re
import hashlib
import os
from colors import Colors

def get_file_hash(filepath):
    """Вычисляет SHA256 хэш файла."""
    if not os.path.exists(filepath) or os.path.isdir(filepath): return None
    h = hashlib.sha256()
    with open(filepath, 'rb') as f:
        while True:
            chunk = f.read(8192)
            if not chunk: break
            h.update(chunk)
    return h.hexdigest()

def execute_commands(commands_str):
    """
    Выполняет блок shell-команд.
    Возвращает кортеж: (success, failed_command, error_message)
    """
    print(f"{Colors.OKBLUE}  [Детали] Запуск выполнения блока команд...{Colors.ENDC}")

    # ИЗМЕНЕНО: Более надежный способ поиска путей, включая те, что в кавычках
    filepaths = re.findall(r'[\'"]?([a-zA-Z0-9_\-\.\/]+)[\'"]?', commands_str)
    
    # Собираем информацию о состоянии ДО выполнения команд
    hashes_before = {fp: get_file_hash(fp) for fp in filepaths if os.path.isfile(fp)}
    dirs_before = {fp for fp in filepaths if os.path.isdir(fp)}
    files_before = {fp for fp in filepaths if os.path.exists(fp)} # Все пути, включая папки
    
    try:
        is_macos = platform.system() == "Darwin"
        # Для macOS добавляем флаг .bak для sed -i, чтобы он работал как в Linux
        commands_str_adapted = re.sub(r"sed -i ", "sed -i '.bak' ", commands_str) if is_macos else commands_str
        full_command = f"set -e\n{commands_str_adapted}"

        print(f"{Colors.WARNING}⚡️ ЛОГ: Выполняю блок команд (bash, set -e)...{Colors.ENDC}")
        result = subprocess.run(['bash', '-c', full_command], capture_output=True, text=True, encoding='utf-8')

        if result.returncode != 0:
            error_msg = f"Команда завершилась с ненулевым кодом выхода ({result.returncode}).\nОшибка (STDERR): {result.stderr.strip()}"
            print(f"{Colors.FAIL}❌ ЛОГ: КРИТИЧЕСКАЯ ОШИБКА при выполнении блока команд.\n{error_msg}{Colors.ENDC}")
            return False, commands_str, result.stderr.strip() or "Команда провалилась без вывода в stderr."

        if result.stderr:
            print(f"{Colors.WARNING}⚠️  ПРЕДУПРЕЖДЕНИЕ (STDERR от успешной команды):\n{result.stderr.strip()}{Colors.ENDC}")

        # Удаляем временные файлы .bak, созданные sed на macOS
        if is_macos:
            subprocess.run("find . -name '*.bak' -delete", shell=True, check=True, capture_output=True)

        # --- НОВАЯ, БОЛЕЕ НАДЕЖНАЯ ПРОВЕРКА ИЗМЕНЕНИЙ ---
        hashes_after = {fp: get_file_hash(fp) for fp in hashes_before.keys()}
        files_after = {fp for fp in filepaths if os.path.exists(fp)}

        # Проверяем, изменился ли хэш у существующих файлов
        modified_files = any(hashes_before.get(fp) != hashes_after.get(fp) for fp in hashes_before)
        # Проверяем, появились ли новые файлы или папки
        created_paths = files_after - files_before
        
        if not modified_files and not created_paths:
            # Если ничего не изменилось и не создалось - это ошибка логики
            error_msg = ("Команда выполнилась успешно, но не изменила и не создала ни одного файла или папки. "
                         "Вероятно, шаблон (например, в sed) не был найден или путь к файлу неверен.")
            final_error_message = result.stderr.strip() if result.stderr else error_msg
            print(f"{Colors.FAIL}❌ ЛОГ: ОШИБКА ЛОГИКИ: {error_msg}{Colors.ENDC}")
            if result.stderr:
                print(f"Причина из STDERR: {final_error_message}")
            return False, commands_str, final_error_message

        # Если были изменения или создания, все хорошо
        if modified_files:
            print(f"{Colors.OKGREEN}✅ ЛОГ: Блок команд успешно выполнен. Файлы были изменены.{Colors.ENDC}")
        if created_paths:
            print(f"{Colors.OKGREEN}✅ ЛОГ: Блок команд успешно выполнен. Были созданы новые пути: {', '.join(created_paths)}{Colors.ENDC}")
            
        return True, None, None

    except Exception as e:
        print(f"{Colors.FAIL}❌ ЛОГ: Непредвиденная ОШИБКА в исполнителе: {e}{Colors.ENDC}")
        return False, commands_str, str(e)
--- КОНЕЦ КОНТЕКСТА ---
Задача: можешь просто пожалуйста для теста прислать мне ответ с блоком ✋ ТРЕБУЮТСЯ РУЧНЫЕ ДЕЙСТВИЯ:  - я проверяю как работает обновление, спасибо
Проанализируй задачу и предоставь ответ, строго следуя правилам исполнения.

================================================================================
ОТВЕТ (Состояние: EXECUTION, Итерация: 1)
--------------------------------------------------------------------------------
ГОТОВО
```done_summary
Тестовая задача выполнена. Я подготовил блок с ручными действиями для проверки функциональности, как и было запрошено.
```
```manual
Это тестовый блок ручных действий.
1. Убедитесь, что вы видите это сообщение.
2. Подтвердите, что тест прошел успешно.
```
